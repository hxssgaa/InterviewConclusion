工程问题：
简单介绍下Spring MVC的原理
1. Spring中利用了IOC控制反转的机制，也就是把对象的声明周期交给Spring来管理，它的原理是通过web.xml中的ContextLoaderListener来加载各个bean的，它会通过读取context的配置文件找到对应bean的位置，并通过内部反射机制进行bean的创建，并负责bean的生命周期管理
2. 在Spring MVC中，Controller负责请求的处理，它通过DI依赖注入的方式将不同的Service实现注入到Controller的某个接口属性中，从而将Controller和Service具体实现相分离
3. Spring MVC的请求响应流程是：首先请求会到达DispatcherServlet，DispatcherServlet在web.xml中定义，是所有HTTP请求处理的Servlet基类，然后DispatcherServlet会遍历自己的HandlerMapping找到对应HTTP请求的Controller，HandlerMapping是通过在ApplicationContext中扫描@RequestMapping注解的Controller或者通过显式地定义url请求和Controller的关系来实现映射的。然后Controller进行实际请求的处理，通过调用注入的Service来实现具体的业务逻辑处理，并返回ModelAndView，String或者Map等类型的对象，最后Spring MVC会用View Resolver来封装Controller返回的数据，并最终解析成鸡腿的View资源并渲染给客户端，从而完成一个HTTP的请求响应。
Spring MVC和Tomcat是如何融合的？
Spring MVC底层是依赖底层的DispatcherServlet来实现url映射到某个具体Controller来实现业务处理的，DispatcherServlet实现了Servlet的service接口，负责所有HTTP请求的处理，在doDispatch方法中将HttpServletRequest和HttpServletResponse交给HandlerAdapter进行处理，从而调用Controller的某个方法进行处理。
反向代理服务器Nginx的原理
Nginx是一个高性能HTTP以及反向代理服务器，它通过异步阻塞的方式处理请求，支持高并发。当客户端发送一个HTTP请求时，如果是静态文件资源可以直接反向代理，如果是动态资源，它会先将用户请求缓存到Nginx服务器中，然后再由Nginx服务器向应用服务器发起连接获取数据，从而降低了应用服务器的负载，从而将并发连接压力转到Nginx服务器上，由于代理服务器与上游应用服务器走的是内网传输，因此传输速度较快。并且Nginx可以通过轮询、基于权重或者IP hash等方式配置多个上游应用服务器来实现Web应用的负载均衡。
Nginx底层采用了事件驱动的架构，即事件源不断产生事件，然后由多个事件收集器来消费这些事件，类似于生产者-消费者模式。并且Nginx采用了一个master进程和多个worker进程的协作方式从而利用了服务器的多核能力。同时Nginx实现了简单的内存池，在一个请求开始创建内存池，并在请求结束的时候销毁内存池，从而减少频繁申请内存的次数，提升并发数。
Nginx负载均衡的方式：
1. 加权轮询
nginx通过dfs搜索的方式，首先将请求都转发给高权重的机器。直到这个机器的权值比其它机器低，才将请求分给下一个高权重的机器。
2. ip_hash
保证同一个ip可以访问到集群中相同的服务器，通过ip的hash值来选择机器。这其实为服务器的均衡留下的隐患，好处是同一个ip的用户可以访问到相同的机器。
3. 一致性hash
通过一致性hash算法通过某个变量映射到不同的服务器上。一致性hash算法就是将服务器的某个唯一标识变量映射到一个固定空间的桶中，比如0~(2^32)-1的空间中，可以将这个空间想象成一个环形 ，当要存储一个键值对的时候，直接将Key映射到这个环里，并且将这个键值对存入到离这个Key顺时针最近的服务器节点上。在新服务器节点加入时，只有一部分的键值对需要重新转存入到新节点上，减少了数据的迁移数量，减少了服务器的压力。
简单介绍下ZooKeeper
ZooKeeper是一个分布式地协调管理框架，可以用于为分布式应用提供一致性服务，比如分布式锁等应用。在ZooKeeper中的底层用了ZNode数据节点实现，该数据结构是一个树形结构，每个ZNode存放自己的数据内容，ZNode分成持久节点和临时节点。在ZooKeeper中保证了顺序一致性和原子性，也就是按照客户端的请求顺序应用到ZooKeeper中，利用该特性可以实现分布式锁的功能，原理就是检测新创建的ZNode节点在拉取的某个key下挂载的所有ZNode节点的位置，如果该位置是第一个，则获取到锁，否则进入等待状态，并通过Watcher监听前一个获取锁节点的状态，直到该节点被删除之后再尝试获取锁。
ZooKeeper是基于发布/订阅者模式来进行数据管理的，在ZooKeeper中同时又推(Push)模式和拉(Pull)模式，也就是推拉结合，推模式中服务器会主动发送数据给订阅的客户端，而拉模式是客户端主动请求获取最新的数据，比如Dubbo在进行远程RPC调用的时候就是通过向ZooKeeper服务器拉取远程RPC提供者的服务器ip数据进行调用的。
简单介绍下Dubbo
Dubbo框架是一个分布式服务框架，用作SOA，实现RPC调用。
Dubbo包括了Provider、Consumer、Registry和Monitor等模块，Provider为服务的提供者，定义了各个提供服务的Service接口及Service实现Bean。Consumer为服务消费者，用于定义依赖的RPC服务接口。Registry负责服务地址的注册于发现，支持Multicast、ZooKeeper等注册中心方式，采用ZooKeeper注册中心时，在进行RPC请求的时候Dubbo会向ZooKeeper拉取远程RPC服务提供者的信息从而建立连接进行通信。
介绍下Dubbo底层通信的机制
Dubbo底层运用了Mina和Netty网络通信框架，底层基于Java NIO，也就是同步非阻塞，适合连接数多但是连接时间短的情况，其实现了连接多路复用的功能，减少了握手次数，提高了性能。相比之下，AIO（异步非阻塞IO）适合于数目多且连接比较长的架构，用户进程发起的IO操作会立刻返回。

基础问题：
Java的多线程同步机制总结：
1. 利用锁的方式，包括可重入锁ReentrantLock和synchronised方法，还包括了分布式锁等
2.利用volatile关键字，可以处理一些线程同步的问题。
3.利用原子操作AtomicInteger等类。
4.使用ThreadLocal
5. 利用ConcurrentHashMap，Hashtable等集合类保证集合线程安全
6. 使用线程池ExecuteService来完成线程之间的管理。
7. 使用信号量Semaphore来实现同步.
8. 利用CyclicBarrier和CountDownLatch来实现同步
Java中的ConcurrentHashMap是如何实现的？
答：采用分段锁，将HashMap分成几个HashTable，由元素HashCode决定存放位置
HashTable与HashMap区别：
1. HashTable线程安全，HashMap线程不安全，效率是HashMap会高一些，
2. HashMap允许null key值或者null value值，这个是因为HashTable对于null值的key没有映射hashcode，而HashMap的null值hashcode为0
HashTable的内部实现机制：
HashTable的内部实现是使用拉链法（详解拉链法，就是一个散列表存放着一个列表，可以减少散列值冲突），hashtable的key值不能为null是为了线程安全的考虑
ConcurrentHashMap和HashTable的区别？
ConcurrentHashMap的写线程才需要锁，但是读线程基本上不受限制，因此可以提高并发的性能
ConcurrentHashMap只有请求size方法才需要锁住表，因此性能非常高
ConcurrentHashMap采用的就是分段锁的机制，默认并发度为16，而hash table会锁住所有的表
HashTable的迭代器是强一致性的，而ConcurrentHashMap的迭代器是弱一致性的，因此ConcurrentHashMap的put之后再get并不一定保证能取出元素
GC问题：
程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，但是Java堆和方法区不是这样
Java使用了可达性分析算法来判定一个对象是否存活，这个方法从一个GC的根节点向下搜索，如果一个对象与GC根节点没有任何连接，就说明这个对象是不可达的。
如果这个对象不可达，那么它将会被第一次标记，并进行第一次筛选，就是看这个对象有没有实现finalize方法，finalize方法是拯救这个对象被回收的最后一次机会，如果没有的话，这个对象就完全被回收了。
方法区的回收必须是这个类所有实例被回收，classLoader被回收，并且Class对象没有任何地方引用并且无法通过反射调用才行。
垃圾回收的算法：
标记-清除法：首先通过可达性分析算法将对象进行标记，然后再统一回收标记的对象，但缺点是容易产生内存碎片。
复制法：针对于新生代来说可以用（将可用内存分成大小相等两份）。
标记-整理法：针对于老年代可以用。
分代回收法：根据老年代与新生代选取合适的方法
数据库事务隔离级别：
由低到高依次为
Read uncommitted(脏读)，所有事务都能看到未提交的执行结果
Read committed(不可重复读)，在这种情况下，一个用户运行同一语句两次，可能看到的结果是不同的
Repeatable read（可重复读），确保了启用事务后，多个线程读数据的时候，会看到同样的数据，但会出现一个幻读的问题
Serializable（幻读），通过强制事务排序的方式解决幻读问题
事务的几个特性：
（ACID）
原子性：事务是原子操作
一致性：事务开始和结束的数据保持一致
隔离性：保证事务独立
持久性：事务完成后的修改是永久的。
讲下MySQL的索引：
在MySQL中InnoDB有B+树索引，Hash索引。
在对某个字段创建索引之后，InnoDB会在底层创建一个索引表。底层是用B+树实现，B+树的叶子节点有横向的指针，便于顺序遍历。
在InnoDB中只有主键索引的叶子节点不仅包括了索引字段还包括了其它字段，二级索引的叶子节点仅包括了索引字段和主键值。
因此顺序的主键插入性能较高。
哈希索引一般用在Memory引擎或者InnoDB中的一些内存索引结构，底层依赖哈希表实现。

